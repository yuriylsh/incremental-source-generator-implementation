using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AutoProperty.Generator;

[Generator]
public class AutoPropertyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a simple filter to find classes that might implement interfaces
        // the <string> generic parameter is the type that is returned by the transform function
        var pipeline = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => NodeIsEligibleForGeneration(node),
                transform: static (ctx, _) => TransformNode(ctx, _))
            .Where(static x => x.HasValue) // filter out null
            .Select(static (x, _) =>
                x!.Value); // force result to the nullable value so GenerateOutput doesn't receive null parameters

        context.RegisterSourceOutput(pipeline, GenerateOutput);
    }


    private static bool NodeIsEligibleForGeneration(SyntaxNode node)
        => node is TypeDeclarationSyntax { BaseList.Types.Count: > 0 }
            and (ClassDeclarationSyntax or RecordDeclarationSyntax);

    private static (string NamespaceName, string ClassName)? TransformNode(GeneratorSyntaxContext generatorContext,
        CancellationToken cancellationToken)
    {
        var typeDeclaration = (TypeDeclarationSyntax)generatorContext.Node;
        if (typeDeclaration.Parent is not BaseNamespaceDeclarationSyntax namespaceDeclarationSyntax)
        {
            return null;
        }

        return (namespaceDeclarationSyntax.Name.ToString(), typeDeclaration.Identifier.ValueText);
    }

    private static void GenerateOutput(SourceProductionContext context,
        (string NamespaceName, string ClassName) classToGenerate)
    {
        // use an interopolated multi-line string for simplicity. 
        // This could also be done with a StringBuilder or some type of class builder.
        var sourceText = $$"""
                           /// <auto-generated>
                           namespace {{classToGenerate.NamespaceName}}
                           {
                               partial class {{classToGenerate.ClassName}}
                               {
                               }
                           }
                           """;


        context.AddSource($"{classToGenerate.NamespaceName}.{classToGenerate.ClassName}.g.cs", sourceText);
    }
}