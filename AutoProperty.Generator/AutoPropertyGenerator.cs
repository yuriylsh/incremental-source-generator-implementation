using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using StronglyTypedIds;

namespace AutoProperty.Generator;

[Generator]
public class AutoPropertyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a simple filter to find classes that might implement interfaces
        // the <string> generic parameter is the type that is returned by the transform function
        var pipeline = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => NodeIsEligibleForGeneration(node),
                transform: static (ctx, _) => TransformNode(ctx, _))
            .Where(static x => x is not null); // filter out null

        context.RegisterSourceOutput(pipeline, GenerateOutput);
    }


    private static bool NodeIsEligibleForGeneration(SyntaxNode node)
        => node is TypeDeclarationSyntax { BaseList.Types.Count: > 0 }
            and (ClassDeclarationSyntax or RecordDeclarationSyntax);

    private static ClassToGenerate TransformNode(
        GeneratorSyntaxContext generatorContext,
        CancellationToken cancellationToken)
    {
        var typeDeclaration = (TypeDeclarationSyntax)generatorContext.Node;
        var symbol = generatorContext.SemanticModel.GetDeclaredSymbol(typeDeclaration, cancellationToken);
        // Classes (and interfaces) are represented as an INamedTypeSymbol in the model
        // INamedTypeSymbol is conceptually similar to System.Type
        if (symbol is not INamedTypeSymbol classSymbol)
        {
            // this shouldn't happen, given we're filtering to ClassDeclarations. But having it puts a safe guard in place so the generator does fail/crash.
            return null;
        }

        // Get a list of all the properties implemented by the class.
        var classProperties = new HashSet<string>(classSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Select(x => x.Name)
        );

        // Get all the interfaces implemented by the class, and all properties from each interface.
        var interfaceProperties = classSymbol.AllInterfaces
            .SelectMany(i => i.GetMembers().OfType<IPropertySymbol>());

        // Compare and filter out any properties that are already implemented by the class 
        var unimplementedProperties = interfaceProperties
            .Where(p => !classProperties.Contains(p.Name))
            .Select(i => new PropertyToGenerate()
            {
                Visibility = "public",
                Type = i.Type.ToDisplayString(),
                Name = i.Name,
                HasGet = i.GetMethod != null,
                HasSet = i.SetMethod != null,
                IsInit = i.SetMethod is {IsInitOnly: true},
            })
            .ToArray();

        // Add the unimplemented properties in the return result
        return new ClassToGenerate
        {
            NamespaceName = classSymbol.ContainingNamespace.ToDisplayString(),
            ClassName = classSymbol.Name,
            Properties = new EquatableArray<PropertyToGenerate>(unimplementedProperties)
        };
    }

    private static void GenerateOutput(SourceProductionContext context,
        ClassToGenerate classToGenerate)
    {
        var formattedProperties = classToGenerate.Properties.Select(i =>
        {
            var getAccessor = i.HasGet ? "get;" : "";
            var setAccessor = i.HasSet ? "set;" : "";

            setAccessor = i.IsInit ? "init;" : setAccessor;

            return $"{i.Visibility} {i.Type} {i.Name} {{ {getAccessor} {setAccessor} }}";
        });
        // use an interpolated multi-line string for simplicity. 
        // This could also be done with a StringBuilder or some type of class builder.
        var properties = string.Join("\n\n\t\t\t", formattedProperties);
        var sourceText = $$"""
            /// <auto-generated>
            namespace {{classToGenerate.NamespaceName}}
            {
                partial class {{classToGenerate.ClassName}}
                {
                    {{properties}}
                }
            }
            """;


        context.AddSource($"{classToGenerate.NamespaceName}.{classToGenerate.ClassName}.g.cs", sourceText);
    }
}

internal record ClassToGenerate
{
    public string NamespaceName { get; set; }
    
    public string ClassName { get; set; }
    
    public EquatableArray<PropertyToGenerate> Properties { get; set; }
}

internal record PropertyToGenerate
{
    public string Visibility { get; set; }

    public string Name { get; set; }

    public string Type { get; set; }

    public bool HasGet { get; set; }

    public bool HasSet { get; set; }

    public bool IsInit { get; set; }
}